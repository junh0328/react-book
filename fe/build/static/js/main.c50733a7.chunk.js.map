{"version":3,"sources":["chapter/imgs/JSX2.png","chapter/imgs/JSX3.png","chapter/imgs/JSX4.png","Home.js","chapter/Chapter1.js","chapter/Chapter2.js","App.js","index.js"],"names":["module","exports","Home","className","Chapter1","Chapter2","src","JSX2","alt","JSX3","JSX4","App","to","path","exact","component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.c50733a7.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/JSX2.784e14da.png\";","module.exports = __webpack_public_path__ + \"static/media/JSX3.17233fb9.png\";","module.exports = __webpack_public_path__ + \"static/media/JSX4.afda2609.png\";","import React from 'react';\r\nimport './Home.css';\r\n\r\nfunction Home() {\r\n\treturn (\r\n\t\t<div className=\"wrap\">\r\n\t\t\t<h1>홈</h1>\r\n\t\t\t<p>안녕하세요. 홈페이지에 오신 걸 환영합니다.</p>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Home;\r\n","import React from 'react';\r\nimport './Chapter.css';\r\nfunction Chapter1() {\r\n\treturn (\r\n\t\t<div className=\"wrap\">\r\n\t\t\t<h1 className=\"chapter__main\">chapter 1</h1>\r\n\t\t\t<h2 className=\"chapter__sub\">1.1 왜 리액트인가?</h2>\r\n\t\t\t<p className=\"chapter__contenrs\">\r\n\t\t\t\t최근 몇 년간 전 세계 개발자는 자바스크립트에 뜨겁게 열광하고 있습니다.\r\n\t\t\t\t한때 자바스크립트는 웹 브라우저에서 간단한 연산을 하거나 시각적인 효과를\r\n\t\t\t\t주는 단순한 스크립트 언어에 불과했지만, 현재는 웹 어플리케이션에서 가장\r\n\t\t\t\t핵심적인 역할을 합니다. 더 나아가 영역을 확장하여 서버 사이드는 물론\r\n\t\t\t\t모바일, 데스크톱 애플리케이션에서도 엄처나게 활약합니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\t이제는 자바스크립트만으로도 규모가 큰 애플리케이션을 만들 수 있는 시대가\r\n\t\t\t\t왔습니다. 대규모 애플리케이션 중 프런트엔드 사이드에서 돌아가는\r\n\t\t\t\t애플리케이션 구조를 관리하려면 어떻게 해야 할까요? 솔직히 이런\r\n\t\t\t\t애플리케이션을 특별한 도구 없이 순수하게 자바스크립트로만 관리하려면\r\n\t\t\t\t골치 아프겠죠? 지금까지 수많은 프레임워크가 조금씩 다른 관점에서 이를\r\n\t\t\t\t해결하려고 노력해 왔습니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\t이 프레임워크들은 주로 MVC(model-view-controller) 아키텍처,\r\n\t\t\t\tMVVM(model-view-view model)아키텍처를 사용합니다. MVC, MVVM, MVW 등과\r\n\t\t\t\t같은 여러 구조가 지닌 공통점은 모델과 뷰가 있다는 것인데요, 모델은\r\n\t\t\t\t애플리케이션에서 사용하는 데이터를 관리하는 영역이고, 뷰는 사용자에게\r\n\t\t\t\t보이는 부분입니다. 프록램이 사용자에게서 어떤 작업(예: 버튼 클릭, 텍스트\r\n\t\t\t\t입력 등)을 받으면 컨트롤러는 모델 데이터를 조회하거나 수정하고, 변경된\r\n\t\t\t\t사항을 뷰에 반영합니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t예를 들어 JSON 파일의 객체중 likes 라는 객체의 값이 1 증가 시키고 싶을\r\n\t\t\t\t때, likes 요소를 찾아 내부를 수정해야겠지요? 업데이트하는 항목에 따라\r\n\t\t\t\t어떤 부분을 찾아서 변경할지 규칙을 정하는 작업은 간단하지만,\r\n\t\t\t\t애플리케이션 규모가 크면 상당히 복잡해지고 제대로 관리하지 않으면 성능도\r\n\t\t\t\t떨어질 수 있습니다. 페이스북 개발 팀은 이를 해결하려고 하나의 아이디어를\r\n\t\t\t\t고안해 냈는데, 어떤 데이터가 변할 때마다 어떤 변화를 줄지 고민하는 것이\r\n\t\t\t\t아니라 그냥 기존 뷰를 날려 버리고 처음부터 새로 렌더링하는 방식입니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t하지만, 이것이 과연 가능할까요? 웹 브라우저에서 이 방식대로 하면 CPU\r\n\t\t\t\t점유율도 크게 증가할텐데요. DOM은 느리니까요. 페이스북 개발팀이 앞서\r\n\t\t\t\t설명한 방식으로 최대한 성능을 아끼고 편안한 사용자 경험을 제공하면서\r\n\t\t\t\t구현하고자 개발한 것이 바로 <b className=\"under_line\">리액트(react)</b>\r\n\t\t\t\t입니다.\r\n\t\t\t</p>\r\n\t\t\t<h2 className=\"chapter__sub\">1.1.1 리액트의 이해</h2>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t리액트는 자바스크립트 라이브러리로 사용자 인터페이스를 만드는데\r\n\t\t\t\t사용합니다. 구조가 MVC, MVW 등인 프레임워크와 달리, 오직 V(View)에만\r\n\t\t\t\t신경 쓰는 라이브러리입니다. 리액트 프로젝트에서 특정 부분이 어떻게\r\n\t\t\t\t생길지 정하는 선언체가 있는데, 이를\r\n\t\t\t\t<b className=\"under_line\"> 컴포넌트</b>라고 합니다. 컴포넌트는 다른\r\n\t\t\t\t프레임워크에서 사용자 인터페이스를 다룰 때 사용하는 템플릿과는 다른\r\n\t\t\t\t개념입니다. 템플릿은 보통 데이터셋이 주어지면 HTML 태그 형식을 문자열로\r\n\t\t\t\t반환하는데,{' '}\r\n\t\t\t\t<span className=\"under_line\">\r\n\t\t\t\t\t이와 달리컴포넌트는 재사용이 가능한 API로 수많은 기능들을 내장하고\r\n\t\t\t\t\t있으며, 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을\r\n\t\t\t\t\t정의합니다.\r\n\t\t\t\t</span>\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t사용자 화면에 뷰를 보여 주는 것을 <b>렌더링</b>이라고 합니다. 리액트\r\n\t\t\t\t라이브러리는 뷰를 어떻게 렌더링하길래 데이터가 변할 때마다 새롭게\r\n\t\t\t\t리렌더링하면서 성능을 아끼고, 최적의 사용자 경험을 제공할 수 있을까요?\r\n\t\t\t\t이 비밀을 파악하려면 리액트 컴포넌트가 최초로 실행한{' '}\r\n\t\t\t\t<b>'초기 렌더링'</b>과 컴포넌트의 데이터 변경으로 다시 실행되는{' '}\r\n\t\t\t\t<b>'리렌더링'</b> 개념을 이해해야 합니다.\r\n\t\t\t</p>\r\n\t\t\t<h2 className=\"chapter__sub\">1.1.1.1 초기 렌더링</h2>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t어떤 UI 관련 프레임워크, 라이브러리를 사용하는지 간에 맨 처음 어떻게\r\n\t\t\t\t보일지를 정하는 초기 렌더링이 필요합니다. 리액트 에서는 이를 다루는\r\n\t\t\t\trender() 함수가 있습니다. 이 함수는 컴포넌트가 어떻게 생겼는지 정의하는\r\n\t\t\t\t역할을 합니다. 이 함수는 html 형식의 문자열을 반환하지 않고, 뷰가 어떻게\r\n\t\t\t\t생겼고 어떻게 작동하는지에 대한 정보를 지닌 객체를 반환합니다. 이렇게\r\n\t\t\t\t컴포넌트의 렌더링 작업이 끝나면 지니고 있는 정보들을 사용하여 HTML,\r\n\t\t\t\t마크업을 만들고, 이를 우리가 정하는 실제 페이지의 DOM 요소 안에\r\n\t\t\t\t주입합니다.\r\n\t\t\t</p>\r\n\t\t\t<p>\r\n\t\t\t\t컴포넌트를 실제 페이지에 렌더링할 때는 분리된 두 가지 절차를 따릅니다.\r\n\t\t\t\t<ul>\r\n\t\t\t\t\t<li>문자열 형태의 HTML 코드를 생성합니다.</li>\r\n\t\t\t\t\t<li>특정 DOM에 해당 내용을 주입하면 이벤트가 적용됩니다.</li>\r\n\t\t\t\t</ul>\r\n\t\t\t</p>\r\n\t\t\t<h2 className=\"chapter__sub\">1.1.1.2 조화 과정</h2>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t리액트에서 뷰를 업데이트할 때는 \"업데이트 과정을 거친다\"라고 하기 보다는\r\n\t\t\t\t<b>\"조화\"</b> 과정을 거친다라고 하는 것이 더 정확한 표현입니다.{' '}\r\n\t\t\t\t<span className=\"under_line\">\r\n\t\t\t\t\t컴포넌트에서 데이터에 변화가 있을 때 우리가 보기에는 변화에 따라 뷰가\r\n\t\t\t\t\t변형되는 것처럼 보이지만, 사실은 새로운 요소를 갈아끼우기 때문입니다.\r\n\t\t\t\t</span>\r\n\t\t\t\t이 작업 또한 render 함수가 맡아서 합니다. 컴포넌트는 데이터를\r\n\t\t\t\t업데이트했을 때 단순히 값을 수정하는 것이 아니라, 새로운 데이터를 가지고\r\n\t\t\t\trender 함수를 또 다시 호출합니다. 하지만, 이때 render 함수가 반환하는\r\n\t\t\t\t결과를 곧바로 DOM에 반영하지 않고, 이전에 render 함수가 만들었던\r\n\t\t\t\t컴포넌트 정보와 현재 render 함수가 만든 컴포넌ㅌ 정보를 비교합니다. 두\r\n\t\t\t\t가지 뷰를 최소한의 연산으로 비교한 후, 둘의 차이를 알아내 최소한의\r\n\t\t\t\t연산으로 DOM 트리를 업데이트하는 것이죠.\r\n\t\t\t</p>\r\n\t\t\t<h2 className=\"chapter__sub\">1.2 리액트의 특징</h2>\r\n\t\t\t<h2 className=\"chapter__sub\">1.2.1 Virtual DOM</h2>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\tDOM은 Document Object Model의 약어입니다. 즉, 객체로 문서 구조를\r\n\t\t\t\t표현하는 방법으로 XML이나 HTML로 작성합니다. 웹 브라우저는 DOM을\r\n\t\t\t\t활용하여 객체에 자바스크립트와 CSS를 적용합니다. DOM은 트리 형태라서\r\n\t\t\t\t특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입할 수 있습니다.\r\n\t\t\t\t요즘 DOM API를 수많은 플랫폼과 웹 브라우저에 사용하는데, 이 DOM에는\r\n\t\t\t\t치명적인 한 가지 문제점이 있습니다. 바로 동적 UI에 최적화되어 있지\r\n\t\t\t\t않다는 것입니다. HTML은 자체적으로는 정적입니다. 자바스크립트를 사용하여\r\n\t\t\t\t이를 동적으로 만들어줄 수 있습니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\tDOM 자체는 빠릅니다. 하지만, DOM 자체를 읽고 쓸 때의 성능은 자바스크립트\r\n\t\t\t\t객체를 처리할 때의 성능과 비교하여 다르지 않습니다. 단, 웹 브라우저\r\n\t\t\t\t단에서 DOM에 변화가 일어나면 웹 브라우저가 CSS를 다시 연산하고,\r\n\t\t\t\t레이아웃을 구성하고, 페이지를 리페인트합니다. 이 과정에서 시간이\r\n\t\t\t\t허비되는 것입니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t<b className=\"chpater__contents\">해결법</b>\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\tHTML 마크업을 시각적인 형태로 변환하는 것은 웹 브라우저가 하는 주\r\n\t\t\t\t역할이기 때문에, 이를 처리할 때 컴퓨터 자원을 사용하는 것은 어쩔 수\r\n\t\t\t\t없습니다. DOM을 조작할 때마다 엔진이 웹 페이지를 새로 그리기 때문에\r\n\t\t\t\t업데이트가 너무 잦으면 성능이 저하될 수 있습니다. 따라서 우리는 DOM을\r\n\t\t\t\t최소한으로 조작하여 작업을 처리하는 방식으로 개선할 수 있습니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\tVirtual DOM을 사용하면 실제 DOM에 접근하여 조작하는 대신 이를 추상화한\r\n\t\t\t\t자바스크립트 객체를 구성하여 사용합니다. 마치 실제 DOM의 가벼운 사본과\r\n\t\t\t\t비슷합니다. 리액트에서 데이터가 변하여 웹 브라우저에 실제 DOM을\r\n\t\t\t\t업데이트할 때는 다음 세 가지 절차를 밟습니다.\r\n\t\t\t\t<ul>\r\n\t\t\t\t\t<li>전체 UI를 Virtual DOM에 리렌더링</li>\r\n\t\t\t\t\t<li>이전 내용과 현재 내용을 비교</li>\r\n\t\t\t\t\t<li>바뀐 부분만 실제 DOM에 적용</li>\r\n\t\t\t\t</ul>\r\n\t\t\t\t리액트와 Virtual DOM이 언제나 제공할 수 있는 것은 바로 업데이트 처리\r\n\t\t\t\t간결성입니다. UI를 업데이트하는 과정에서 생기는 복잡함을 모두 해소하고,\r\n\t\t\t\t더욱 쉽게 업데이트에 접근할 수 있습니다.\r\n\t\t\t</p>\r\n\t\t\t<h2 className=\"chapter__sub\">1.2.2 기타 특징</h2>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t일부 웹 프레임워크가 MVC 또는 MVW 등의 구조를 지향하는 것과 달리\r\n\t\t\t\t리액트는 오직 뷰만 담당합니다. 다시 한 번 강조하면 리액트는 프레임워크가\r\n\t\t\t\t아니라 라이브러리입니다. 다른 웹 프레임워크가 Ajax, 데이터 모델링,\r\n\t\t\t\t라우팅 등과 같은 기능을 내장하고 있는 반면, 리액트는 정말 뷰만 신경 쓰는\r\n\t\t\t\t라이브러리이므로 기타 기능은 직접 구현하여 사용해야 합니다. 하지만, 너무\r\n\t\t\t\t걱정할 필요는 없습니다. 다른 개발자들이 만든 라이브러리, 즉 라우팅에는\r\n\t\t\t\t리액트 라우터, Ajax 처리에는 axios, fetch, 상태 관리에는 리덕스나,\r\n\t\t\t\tMobX를 사용하여 빈 자리를 채우면 됩니다. 해당 분야에서 마음에 드는\r\n\t\t\t\t라이브러리를 사용하면 되니까 자신의 취향대로 스택을 설정할 수 있다는\r\n\t\t\t\t장점이 있지만, 여러 라이브러리를 접해야 한다는 단점도 있습니다.\r\n\t\t\t</p>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Chapter1;\r\n","import React from 'react';\r\nimport './Chapter.css';\r\nimport JSX2 from './imgs/JSX2.png';\r\nimport JSX3 from './imgs/JSX3.png';\r\nimport JSX4 from './imgs/JSX4.png';\r\n\r\nfunction Chapter2() {\r\n\treturn (\r\n\t\t<div className=\"wrap\">\r\n\t\t\t<h1 className=\"chapter__main\">chapter 2</h1>\r\n\t\t\t<h2 className=\"chapter__sub\">2.1 코드 이해하기</h2>\r\n\t\t\t<p className=\"chapter__contents\">import React from 'react';</p>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\t이 코드는 리액트를 불러와서 사용할 수 있게 해 줍니다. 리액트 프로젝트를\r\n\t\t\t\t만들 때 node_modules라는 디렉터리도 함께 생성되는데요, 프로젝트 생성\r\n\t\t\t\t과정에서 node_modules 디렉터리에 react 모듈이 설치됩니다. 그리고 이렇게\r\n\t\t\t\timport 구문을 통해 리액트를 불러와서 사용할 수 있는 것이죠. 여기서 한\r\n\t\t\t\t가지 알아 둘 점이 있습니다. 아렇게 모듈을 불러와서 사용하는 것은 사실\r\n\t\t\t\t원래 브라우저에는 없던 기능입니다. 브러우저가 아닌 환경에서\r\n\t\t\t\t자바스크립트를 실행할 수 있게 해주는 환경인 Node.js에서 지원하는\r\n\t\t\t\t기능입니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\t이러한 기능을 브라우저에서도 사용하기 위해 <b>번들러(bundler)</b>를\r\n\t\t\t\t사용합니다. 대표적인 번들러로 웹팩, Parcel, browserify라는 도구들이\r\n\t\t\t\t있으며, 각 도구마다 특성이 다릅니다. 리액트 프로젝트에서는 주로 웹팩을\r\n\t\t\t\t사용하는 추세입니다. 편의성과 확장성이 다른 도구들보다 뛰어나기\r\n\t\t\t\t때문입니다. 번들러 도구를 사용하면 import (또는 require)로 모듈을\r\n\t\t\t\t불러왔을 때 불러온 모듈을 모두 합쳐서 하나의 파일을 생성해 줍니다. 또\r\n\t\t\t\t최적화 과정에서 여러 개의 파일을 분리될 수도 있습니다. 이책의\r\n\t\t\t\t프로젝트에서는 <b>src/index.js</b>를 시작으로 필요한 파일을 다 불러와서\r\n\t\t\t\t번들링하게 됩니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t리액트를 불러오는 코드 하단에는 다음과 같이 SVG 파일과 CSS 파일을 import\r\n\t\t\t\t하는 코드가 있습니다.\r\n\t\t\t\t<ul>\r\n\t\t\t\t\t<li>import logo from './logo.svg';</li>\r\n\t\t\t\t\t<li>import './App.css';</li>\r\n\t\t\t\t</ul>\r\n\t\t\t\t웹팩을 사용하면 SVG 파일과 CSS 파일도 불러와서 사용할 수 있습니다.\r\n\t\t\t\t이렇게 파일들을 불러오는 것은 웹팩의 <b>로더</b> 라는 기능이 담당합니다.\r\n\t\t\t\t로더는 여러 가지 종류가 있습니다. babel-loader는 자바스크립트 파일들을\r\n\t\t\t\t불러오면서 최신 자바스크립트 문법으로 작성된 코드를 바벨이라는 도구를\r\n\t\t\t\t사용하여 ES5 문법으로 변환해 줍니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chpater__contents\">\r\n\t\t\t\t<b> 최신 자바스크립트로 작성된 코드를 왜 변환하나요?</b>\r\n\t\t\t\t<br />\r\n\t\t\t\tES5는 이전 버전의 자바스크립트를 의미합니다. 최신 자바스크립트 문법을\r\n\t\t\t\tES5 형태로 변환하는 것은 구버전 웹 브라우저와 호환하기 위해서입니다.\r\n\t\t\t\t현재 대부분의 최신 웹 브라우저에서는 자체적으로 최신 자바스크립트 문법을\r\n\t\t\t\t바로 실행할 수 있지만, 구버전 웹 브라우저에서는 실행되지 않기 때문에\r\n\t\t\t\t사전에 꼭 변환해 주어야 합니다. 또한, 우리가 앞으로 배우게 될 리액트\r\n\t\t\t\t컴포넌트에서 사용하는 JSON 문법도 정식 자바스크립트 문법이 아니므로 ES5\r\n\t\t\t\t형태의 코드로 변환해야 합니다.\r\n\t\t\t\t<span className=\"under_line\">\r\n\t\t\t\t\tES5 이후의 문법들은 ECMAScirpt등과 같은 형태로 이름이 지어집니다.\r\n\t\t\t\t</span>\r\n\t\t\t</p>\r\n\t\t\t<h2 className=\"chapter__sub\">2.2 JSX란?</h2>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\tJSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생겼습니다. 이런\r\n\t\t\t\t형식으로 작성한 코드는 브라우저에서 실행되기 전에 코드가 번들링되는\r\n\t\t\t\t과정에서 바벨을 이용하여 일반 자바스크립트 형태의 코드로 변환됩니다.\r\n\t\t\t</p>\r\n\t\t\t<h2 className=\"chapter__sub\">2.3 JSX의 장점</h2>\r\n\t\t\t<h3 className=\"chapter__sub\">2.3.1 보기 쉽고 익숙하다</h3>\r\n\t\t\t<h3 className=\"chpater__sub\">2.3.2 더욱 높은 활용도</h3>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\tJSX에서는 우리가 알고 있는 div나 span과 같은 HTML 태그를 사용할 수 있을\r\n\t\t\t\t뿐만 아니라, 앞으로 만들 컴포넌트도 JSX 안에서 작성할 수 있습니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\t<p>\r\n\t\t\t\t\t<b> ReactDOM.render는 무엇인가요?</b>\r\n\t\t\t\t</p>\r\n\t\t\t\t이 코드는 컴포넌트를 페이지에 렌더링하는 역할을 하며, react-dom 모듈을\r\n\t\t\t\t불러와 사용할 수 있습니다. 이 함수의 첫 번째 파라미터에는 페이지에\r\n\t\t\t\t렌더링할 내용을 JSX로 작성하고, 두 번째 파라미터에는 해당 JSX를 렌더링할\r\n\t\t\t\tdocument 내부 요소를 설정합니다. 여기서는 id가 root인 요소 안에 렌더링을\r\n\t\t\t\t하도록 설정했는데요, 이 요소는 public/index.html 파일을 열어 보면\r\n\t\t\t\t있답니다.\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\t<b> React.StrictMode는 무엇인가요?</b>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tReact.StrictMode는 리액트 프로젝트에서 리액트의 레거시 기능을 사용하지\r\n\t\t\t\t\t못하게 하는 기능입니다. 이를 사용하면 문자열 ref, componentWillMount\r\n\t\t\t\t\t등 나중에는 완전히 사라지게 될 옛날 기능을 사용했을 때 경고를\r\n\t\t\t\t\t출력합니다. 이 책을 작성할 시점에는 해당 옵션이 기본적으로 적용되어\r\n\t\t\t\t\t있지 않았습니다.\r\n\t\t\t\t</p>\r\n\t\t\t</p>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\t<b>\r\n\t\t\t\t\t리액트 컴포넌트에서 요소 여러 개를 왜 하나의 요소로 꼭 감싸 주어야\r\n\t\t\t\t\t할까요?\r\n\t\t\t\t</b>\r\n\t\t\t\t<p>\r\n\t\t\t\t\tReact 에서 사용하는 Virtual DOM에서 컴포넌트 변화를 감지해낼 때\r\n\t\t\t\t\t효율적으로 비교할 수 있도록 규칙을 세웠기 때문입니다. (컴포넌트 내부는\r\n\t\t\t\t\t반드시 하나의 DOM 트리 구조로 이루어져야 한다.) 여기서 꼭 div 요소를\r\n\t\t\t\t\t사용하고 싶지 않을 수도 있습니다. 그런 경우에는 리액트 <b>v16</b>부터\r\n\t\t\t\t\t도입된 Fragment라는 기능을 사용하면 됩니다.\r\n\t\t\t\t</p>\r\n\t\t\t</p>\r\n\t\t\t<h3 className=\"chapter__sub\">2.4.3 if문 대신 조건부 연산자</h3>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\tJSX 내부의 자바스크립트 표현식에서 if문을 사용할 수는 없습니다. 하지만\r\n\t\t\t\t조건에 따라 다른 내용을 렌더링해야 할 때는 JSX 밖에서 if문을 사용하여\r\n\t\t\t\t사전에 값을 설정하거나, 중괄호 안에 조건부 연산자를 사용하면 됩니다.\r\n\t\t\t\t조건부 여산자의 또 다른 이름은 삼항 연산자입니다.\r\n\t\t\t\t<img src={JSX2} alt=\"JSX2\" className=\"chapter__imgs\" />\r\n\t\t\t</p>\r\n\t\t\t<h3 className=\"chpater__sub\">\r\n\t\t\t\t2.4.4 AND 연산자 (&&)를 사용한 조건부 렌더링\r\n\t\t\t</h3>\r\n\t\t\t<p className=\"chapter__contents\">\r\n\t\t\t\t개발하다 보면 특정 조건을 만족할 때 내용을 보여 주고, 만족하지 않을 때\r\n\t\t\t\t아예 아무것도 렌더링하지 않아야 하는 상황이 올 수 있습니다. 이럴 때도\r\n\t\t\t\t조건부 연산자를 통해 구현할 수는 있습니다.\r\n\t\t\t\t<img src={JSX3} alt=\"JSX3\" className=\"chapter__imgs\" />위 코드와 같이\r\n\t\t\t\tnull을 렌더링 하면 아무것도 보여 주지 않습니다. 하지만 이것보다 더 짧은\r\n\t\t\t\t코드로 똑같은 작업을 할 수 있습니다. 다음과 같이 AND 연산자를 사용해서\r\n\t\t\t\t조건부 렌더링을 할 수 있습니다.\r\n\t\t\t\t<img src={JSX4} alt=\"JSX4\" className=\"chapter__imgs\" />\r\n\t\t\t</p>\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default Chapter2;\r\n","import React from 'react';\r\nimport './App.css';\r\nimport { Route, Link } from 'react-router-dom';\r\nimport Home from './Home';\r\nimport Chapter1 from './chapter/Chapter1';\r\nimport Chapter2 from './chapter/Chapter2';\r\n\r\nfunction App() {\r\n\treturn (\r\n\t\t<div className=\"navbar\">\r\n\t\t\t<ul className=\"navbar__ul\">\r\n\t\t\t\t<li className=\"navbar__li\">\r\n\t\t\t\t\t<Link to=\"/\">홈</Link>\r\n\t\t\t\t</li>\r\n\t\t\t\t<li className=\"navbar__li\">\r\n\t\t\t\t\t<Link to=\"/Chapter1\">챕터 1</Link>\r\n\t\t\t\t</li>\r\n\t\t\t\t<li className=\"navbar__li\">\r\n\t\t\t\t\t<Link to=\"/Chapter2\">챕터 2</Link>\r\n\t\t\t\t</li>\r\n\t\t\t</ul>\r\n\r\n\t\t\t<Route path=\"/\" exact={true} component={Home} />\r\n\t\t\t<Route path=\"/Chapter1\" component={Chapter1} />\r\n\t\t\t<Route path=\"/Chapter2\" component={Chapter2} />\r\n\t\t</div>\r\n\t);\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { BrowserRouter } from 'react-router-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n\t<BrowserRouter>\r\n\t\t<App />\r\n\t</BrowserRouter>,\r\n\tdocument.getElementById('root')\r\n);\r\n"],"sourceRoot":""}